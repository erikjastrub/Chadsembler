"""
MAIN FILE TO BE EXECUTED - THE CHADSEMBLER
"""

import sys
# Add the imports folder to the python imports path
#   so imported modules are searched for in this folder too
sys.path.append("./imports")

# Will check the version of python, ensuring it is minimum 3.10 or above
import checkversion

from defaults import Defaults

from argumentprocessor import ArgumentProcessor  # The first module in the pipeline
from preprocessor import Preprocessor  # The second module in the pipeline 
from lexer import Lexer  # The third module in the pipeline
from parser import Parser  # The fourth module in the pipeline
from semanticanalyser import SemanticAnalyser  # The fifth module in the pipeline
from codegenerator import CodeGenerator  # The sixth module in the pipeline
from virtualmachine import VirtualMachine  # The seventh and final module in the pipeline
from colour import Colour  # Functionality for printing to the terminal in colour

def getSourceCode() -> str:

    # When performing file I/O various exceptions may get raised
    # I can catch these exceptions using the try-except facility

    try:

        # Check to see if the file name ends with the custom chadsembly file extension
        if not sys.argv[1].endswith(".csm"):

            # If not then output a warning in yellow to the terminal
            Colour.colourPrint(Colour.YELLOW, "Chadsembly Warning: file name does not end with a '.csm' file extension")

        # Here I am using a pythonic feature called a context manager
        # This will let me open a file and manipulate it
        # It will automatically close the file for me at the end
        with open(sys.argv[1], 'r') as sourceCodeFile:
            
            # Return the file contents read into a string
            return sourceCodeFile.read()

    # In the case where the file does not exist...
    except FileNotFoundError:

        # Output this error in red as feedback to the user and suspend the program
        sys.exit(f"""{Colour.RED}Cannot assemble a file that does not exist
Try specifying the path to the file if it is located in another directory{Colour.RESET}""")

    # In the case where they did not pass in a file...
    except IndexError:

        # Output this error in red as feedback to the user and suspend the program
        sys.exit(f"{Colour.RED}No file was passed in to be assembled{Colour.RESET}")


def main() -> None:

    chadsemblySourceCode: str = getSourceCode()

    systemConfigurationTable: dict[str, int] = {
        Defaults.CLOCK_CONFIGURATION_OPTION: 0,
        Defaults.MEMORY_CONFIGURATION_OPTION: 100,
        Defaults.REGISTERS_CONFIGURATION_OPTION: 3
    }

    minimumValuesTable: dict[str, int] = {
        Defaults.CLOCK_CONFIGURATION_OPTION: 0,
        Defaults.MEMORY_CONFIGURATION_OPTION: 100,
        Defaults.REGISTERS_CONFIGURATION_OPTION: 3
    }

    # The first argument is the name of the file being executed
    # I will skip over this argument and only argument process the 
    # actual command line arguments fed to the program
    argumentProcessor: ArgumentProcessor = ArgumentProcessor(sys.argv[2:], Defaults.DIRECTIVE_PREFIX, Defaults.TOKEN_DELIMITER, 
                                          systemConfigurationTable, minimumValuesTable)

    # I am using the unpack (*) operator to unpack the tuple returned from the method 
    #   and feed it as arguments to the constructor
    # This self describes the pipeline within the code
    preprocessor: Preprocessor = Preprocessor(*argumentProcessor.argumentProcess(), chadsemblySourceCode, Defaults.COMMENT_PREFIX)

    # Coming after the Preprocessor in the pipeline, I will use the tuple returned from the preprocessor.argumentProcessor()
    # method to instantiate a Lexer object
    lexer: Lexer = Lexer(*preprocessor.preprocess())
    
    # Comes after the Lexer in the pipeline
    # A token stream is needed as input to instantiate a Parser object
    parser: Parser = Parser(*lexer.lex())

    # The instruction pools from the parser are needed as input to instantiate a SemanticAnalyser object
    semanticAnalyser: SemanticAnalyser = SemanticAnalyser(*parser.parse())

    # The semantically correct instruction pools are needed as input to instantiate a SemanticAnalyser object
    # Using the most recent symbol table (the Preprocessor's symbol table), I can then configure the generation of the chadsembly bytecode
    codeGenerator: CodeGenerator = CodeGenerator(*semanticAnalyser.semanticAnalyse(), preprocessor._systemConfigurationTable)

    # The bytecode generated by the CodeGenerator is given as input to instantiate a VirtualMachine object.
    virtualMachine: VirtualMachine = VirtualMachine(*codeGenerator.generateCode())

    # Run the virtual machine and execute the chadsembly bytecode
    virtualMachine.run()

# This selection statement is a file guard
# It will only call the main() function if this file was executed, not imported by another file
if __name__ == "__main__": main()
